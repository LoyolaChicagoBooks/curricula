Data Structures 1 (CS2 / LUC COMP 271)
=======================================


Top 15 topics in CS2 curricula?
-------------------------------


In a typical CS2 course, you may expect to find the following topics covered, although the order and emphasis may vary depending on the particular curriculum and instructor:

- Data Structures

  - Stacks
  - Queues
  - Linked Lists
  - Trees
  - Graphs
  - Hash Tables

- Algorithms

  - Sorting (e.g., QuickSort, MergeSort)
  - Searching (e.g., Binary Search)
  - Graph traversal (e.g., Breadth-First Search, Depth-First Search)
  - Shortest path algorithms (e.g., Dijkstra's Algorithm)

- Object-Oriented Programming

  - Inheritance
  - Polymorphism
  - Abstraction
  - Encapsulation
  
- Recursion
- Algorithm Complexity Analysis
- File I/O and Serialization
- Memory Management
- Error Handling and Exceptions
- Introduction to Concurrency
- Software Engineering Principles
- Basic Design Patterns
- Unit Testing and Test-Driven Development
- Debugging Techniques
- Version Control Systems (e.g., Git)
- Introduction to GUI Programming

Please note that this list is not exhaustive, and the topics covered in a specific CS2 course may vary depending on the institution, curriculum, and instructor.

.. note:: Konstantin will take it from here.


Top 15 CS2 topics as opposed to CS7
-----------------------------------

*Let's consider the ACM 2020 curriculum guidelines. If we split topics in such a way that CS2 focuses on an introduction to data structures and CS7 on more advanced data structures, what should the top 15 CS2-specific topics be? (GPT-4)*

.. warning:: The ACM 2020 curriculum guidelines are not specifically available to me at my last training cut-off in September 2021. 

However, I can provide an example list of topics that are often covered in a typical second course in computer science (CS2), focusing on an introduction to data structures. These topics build upon the basics learned in a CS1 course, such as basic programming constructs, control structures, and introductory object-oriented programming.

Here is a general list of 15 topics:

1. **Review of Basic Programming Concepts:** This might include basic data types, control structures, functions, and classes.

2. **Array and ArrayList:** Understanding of these basic data structures, their uses, and limitations.

3. **Stacks:** Introduction to stack data structures, their uses, and basic operations like push and pop.

4. **Queues:** Similar to stacks, this would cover the concept, uses, and operations of queues.

5. **Linked Lists:** Covers singly-linked and doubly-linked lists, their operations, and use cases.

6. **Recursion:** Understanding of recursive functions and their applications, and the relationship to data structures.

7. **Trees:** Introduction to basic tree structures, tree traversals, and binary trees.

8. **Binary Search Trees:** A more specific tree structure with ordering properties, including operations like insertion and deletion.

9. **Hashing:** Introduction to hash tables, hash functions, collision strategies, and their applications.

10. **Heaps:** Understanding of heap data structures, and algorithms like heap sort.

11. **Graphs:** Introduction to basic graph concepts, representation, and traversals (DFS, BFS).

12. **Sorting Algorithms:** Covers basic sorting algorithms like selection sort, insertion sort, bubble sort, quicksort, mergesort, and heapsort.

13. **Search Algorithms:** Covers linear search and binary search on various data structures.

14. **Algorithm Analysis:** Understanding Big O notation, time complexity, and space complexity.

15. **Software Engineering Principles:** Introduction to basic principles such as code readability, modularity, and debugging techniques.

The exact order and selection of these topics may vary depending on the specific course and curriculum guidelines. Also, real-life examples and problem-solving exercises should be included to apply these data structures and concepts. The complexity and depth of these topics will increase when students move on to more advanced courses like CS7.


CS2 at Loyola: Current topics and learning outcomes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	  
.. todo:: Update as needed.

Here's a version of the list of current topics and learning outcomes of the CS2 course at Loyola, COMP 271.

1. Basics of Object-Oriented Programming: Students will be able to create, use, and understand properly constructed OOP classes with public and private members, constructors, accessors, and mutators. They will also learn how to use method overloading appropriately and create classes with proper encapsulation. Additionally, they will be able to use existing classes and access documentation to find and understand components of classes to create new programs.

2. More Object-Oriented Programming: Building on the basics, students will learn how to create solutions with multiple cooperating OOP classes. They will understand and use basic inheritance and interfaces, apply them to problem-solving, and create well-structured solutions. Students will also know how to use overriding of methods, abstract classes and methods, and interfaces. They will be able to implement common methods appropriately (toString, equals, compareTo, hashCode.) and understand and apply the substitution rule in inheritance. Finally, they will be familiar with boxing and unboxing of primitive types.

3. Sequential Structures: Students will learn to select and use appropriate sequential data structures in problem-solving, including ArrayList, List, Linked List, Queue, Dequeue, and Stack. They will use iterators with sequential data structures, understand how these implementations impact performance (Big-Oh), and learn the implementation of array-based and list-based data structures. They will also be able to create medium scale applications and identify limits when picking appropriate data structures for unfamiliar problems.

4. Algorithms and Recursion: Students will gain an introduction to recursion, its uses and pitfalls, and understand the appropriate uses of recursion and which algorithms using it are likely to perform acceptably. They will be able to analyze when recursion is and is not necessary and appropriate. Students will also extend their ability to predict and compare Big-Oh performance of programs and knowledge of algorithms with an understanding of backtracking and recursion.

5. Sorting and Searching: Students will understand sorting and searching techniques and how they are implemented in linear data structures. They will iterate through information using linear and binary searches, and be able to compare the performance of array-based and linked list sorting and searching.

6. Problem Solving, Testing, Debugging: Students will be able to apply problem-solving techniques to new computing problems, evaluate and select approaches including step-wise refinement, divide and conquer, etc. They will gain introductory experience with test-driven development, be able to define and evaluate test cases appropriate to the problem at hand, and become proficient at applying debugging principles including breakpoints and tracking of variables when code does not work as intended. Students will also understand and apply JUnit for creating and analyzing problems and selecting appropriate techniques.

7. Tools, Organization, Professional Development: Students will become fully proficient at creating, editing, compiling, and running programs using both an Integrated Development Environment and the command line. They will also be able to install and update programming tools on their own computers. Additionally, students will create, grow, and maintain a GitHub account and use it as a repository for class work and projects throughout their continued education at Loyola University Chicago. They will be prepared to use it to demonstrate their experience and non-text materials to be supplied.

8. Code Reading and Inspections, Java Documentation, Programming Style: Students will learn how to effectively read code produced by others, either for learning or finding defects. They will develop a professional-looking programming style, learn to create and use Java doc when reading and writing code, and gain experience interacting with others by doing code reading and inspections. Students will also understand the concept of defects in programs and apply their skills to their own work and the work of others.

9. Introduction to Non-Linear Data Structures: Students will gain an introduction to advanced data structures, including trees, binary trees, and graphs. They will be able to compare these data structures with linear data structures and understand when they may be useful in implementations.


*How would you reconcile your earlier list with our own current set of topics and learning outcomes?*

The list you provided for Loyola's COMP 271 is quite comprehensive and aligns well with the general introductory data structures course topics I initially suggested. I'll try to reconcile the two lists by mapping the suggested topics to your current ones and identifying potential areas of expansion.

1. **Review of Basic Programming Concepts:** This is covered in your "Basics of Object-Oriented Programming" and "More Object-Oriented Programming" sections. Students already learn about the fundamentals of OOP, which is a good foundation for the course.

2. **Array and ArrayList:** This is included in your "Sequential Structures" section where students learn about ArrayList and other linear data structures.

3. **Stacks and Queues:** These topics are also part of your "Sequential Structures" section.

4. **Linked Lists:** Again, part of your "Sequential Structures" section.

5. **Recursion:** This is covered in your "Algorithms and Recursion" section.

6. **Trees:** The basics of tree data structures seem to be covered in the "Introduction to Non-Linear Data Structures" section.

7. **Binary Search Trees:** This is an area where you could consider expanding your "Introduction to Non-Linear Data Structures" section. While you currently introduce trees and binary trees, binary search trees are a specific kind of binary tree with unique properties and operations that might be worth covering.

8. **Hashing:** This topic isn't explicitly mentioned in your current topics. It could be a valuable addition to your course, as hash tables are a commonly used data structure in software development.

9. **Heaps:** This is another topic that could be added to your "Introduction to Non-Linear Data Structures" section. Heaps are a useful type of tree-based data structure.

10. **Graphs:** These are included in your "Introduction to Non-Linear Data Structures" section.

11. **Sorting Algorithms:** This is covered in your "Sorting and Searching" section.

12. **Search Algorithms:** This is also covered in your "Sorting and Searching" section.

13. **Algorithm Analysis:** This is part of your "Algorithms and Recursion" section where students learn about Big-Oh notation and algorithm performance.

14. **Software Engineering Principles:** Your "Problem Solving, Testing, Debugging", "Tools, Organization, Professional Development", and "Code Reading and Inspections, Java Documentation, Programming Style" sections cover various aspects of software engineering principles, such as testing, debugging, and code style.

15. **Advanced Concepts (Optional):** Depending on the pace of the class and the preparedness of the students, more advanced topics such as dynamic programming, greedy algorithms, and understanding of data structures like tries, AVL trees, red-black trees, and disjoint sets could be introduced.

Overall, the Loyola COMP 271 course seems comprehensive and well-structured. Adding a few more topics like hashing, heaps, and binary search trees could make it even more robust.


*Thanks, though we want to cover the most essential topics in depth during our 15-week semester, and we have the opportunity to defer the most advanced topics to our subsequent CS7 course. Which three to five topics do you think would be good candidates for coverage in CS7 instead of CS2?*

Certainly, it's crucial to ensure students have a thorough understanding of fundamental topics before introducing more advanced ones. Here are a few topics that could be deferred to a CS7 course:

1. **Advanced Trees (AVL Trees, Red-Black Trees, B-Trees, etc.):** While CS2 covers basic tree structures and binary search trees, advanced trees like AVL trees, Red-Black trees, and B-trees have more complex balancing algorithms that might be better suited for a more advanced course.

2. **Graph Algorithms:** CS2 introduces basic graph concepts, but more advanced graph algorithms like Dijkstra's, Bellman-Ford, Floyd-Warshall, and algorithms for minimum spanning trees (Kruskal's and Prim's), along with topics like topological sorting, strongly connected components, etc., could be reserved for CS7.

3. **Advanced Data Structures (Hashing, Heaps, Disjoint Sets, Tries):** While basic hashing can be covered in CS2, more advanced topics like open addressing, perfect hashing, universal hashing, and advanced data structures like disjoint set union and tries could be deferred to CS7.

4. **Dynamic Programming and Greedy Algorithms:** These topics involve a higher level of problem-solving skills and a deep understanding of recursion and optimization. They are typically introduced in more advanced algorithms courses.

5. **NP-Completeness and Computational Intractability:** This is a more theoretical aspect of computer science and requires a good understanding of algorithms and their complexities. This would be more suitable for an advanced course.

These topics would provide a solid foundation for a CS7 course and would build nicely on the topics covered in CS2. The exact division of topics will depend on the pace and depth at which the material is covered in CS2, as well as the specific goals of the CS7 course.


*What's your recommended order of the remaining CS2 topics?*

Here's a recommended order for these CS2 topics, with the understanding that some topics will naturally overlap and interweave:

1. **Review of Basic Programming Concepts:** This is a natural starting point, reinforcing the foundations of Object-Oriented Programming (OOP).

2. **Array and ArrayList:** Introduce these fundamental data structures early on, as they're the backbone of many other structures and algorithms.

3. **Stacks and Queues:** These are simple, yet powerful, data structures that can be understood with the foundation of Arrays/ArrayLists.

4. **Linked Lists:** This introduces another way to structure data sequentially, with different performance implications. It's a good lead-in to more complex structures.

5. **Recursion:** Recursion can be a challenging concept for many students, so introducing it relatively early allows more time for practice and reinforcement throughout the course.

6. **Algorithm Analysis:** Once students have seen a few different algorithms (in the form of data structure operations), it's a good time to introduce Big-Oh notation and the concept of time complexity.

7. **Sorting and Searching Algorithms:** With a basic understanding of algorithm analysis, students can start exploring more complex algorithms and comparing their performance.

8. **Trees and Binary Search Trees:** Trees are a key non-linear data structure. Understanding them leads naturally to binary search trees, which are a practical application with important efficiency characteristics.

9. **Hashing:** This is a good point to introduce hashing, which underlies a very efficient (on average) data structure: the hash table.

10. **Software Engineering Principles:** These principles can be introduced and then reinforced throughout the course. However, students will appreciate them more once they've dealt with more complex code.

Remember, this order isn't rigid. Many of these topics naturally overlap, and teaching them isn't necessarily a linear process. For instance, basic algorithm analysis can be introduced as soon as you're discussing different operations on data structures, and then reinforced throughout the course as you introduce more complex algorithms. Similarly, software engineering principles can be woven throughout the course as students write more and more complex code.


*Which of these topics would you consider cross-cutting?*

Cross-cutting topics in a curriculum are those that span multiple areas of study or are applicable to a variety of specific topics. In the context of a CS2 course focused on data structures, these topics often include general principles and methodologies rather than specific technologies or structures. 

Here are the cross-cutting topics from your list:

1. **Review of Basic Programming Concepts:** The principles of object-oriented programming, such as encapsulation, inheritance, and polymorphism, are applicable across a wide range of topics in computer science.

2. **Algorithm Analysis:** Understanding how to analyze the efficiency of algorithms, particularly with Big-O notation, is critical when studying various data structures and algorithms.

3. **Recursion:** This is a fundamental concept that applies to many different data structures and algorithms, such as tree traversals, searching algorithms, and sorting algorithms.

4. **Sorting and Searching Algorithms:** The concepts behind these algorithms are universal and will apply to different data structures. Understanding how to sort and search efficiently is important across a wide range of problem domains.

5. **Software Engineering Principles:** Principles like code readability, modularity, testing, and debugging apply to all areas of software development, not just to data structures and algorithms. These are skills that students will use continuously, no matter what specific topic they're studying.

While it's important to study specific data structures like arrays, trees, and hash tables, these cross-cutting topics provide a framework for understanding how to use those structures effectively and efficiently. They will be revisited and applied repeatedly throughout both this course and subsequent computer science courses.


.. include:: 10-basic-concepts.rst
.. include:: 20-basic-oop.rst
.. include:: 30-arrays-arraylists.rst
.. include:: 35-maps.rst

.. include:: 100-se-principles.rst